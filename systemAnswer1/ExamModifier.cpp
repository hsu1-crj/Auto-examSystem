#include "ExamModifier.h"
#include <iostream>
#include <fstream>
#include <sstream>
#include <codecvt>
#include <locale>
#include <string>
#include <algorithm>

ExamModifier::ExamModifier(const std::string& questionBank) : questionBankFile(questionBank) {
    // 加载所有题目
    allQuestions = Question::loadFromFile(questionBankFile);
}

bool ExamModifier::replaceQuestionInExam() {
    // 获取试卷名称
    std::string examFilename;
    std::cout << "请输入要修改的试卷文件名 (如 exam_001.txt): ";
    std::getline(std::cin, examFilename);

    // 读取试卷 - 使用自定义方法，不使用 Question::loadFromFile
    std::vector<Question> examQuestions = readExamFromFile(examFilename);
    if (examQuestions.empty()) {
        std::cout << "无法读取试卷文件或文件为空! 请检查文件名是否正确。" << std::endl;
        return false;
    }

    // 显示试卷中的题目
    std::cout << "当前试卷包含以下题目：" << std::endl;
    displayExamQuestions(examQuestions);

    // 获取要替换的题目编号
    std::string indexStr;
    std::cout << "请输入要替换的题目序号 (0-" << examQuestions.size() - 1 << "): ";
    std::getline(std::cin, indexStr);
    int index = std::stoi(indexStr);

    if (index < 0 || index >= examQuestions.size()) {
        std::cout << "无效的题目序号!" << std::endl;
        return false;
    }

    // 显示当前题目
    std::cout << "当前题目: " << std::endl;
    std::cout << "[" << examQuestions[index].getId() << "]" << std::endl;
    std::cout << "题干：" << examQuestions[index].getContent() << std::endl;
    std::cout << "知识点：" << examQuestions[index].getTag() << std::endl;
    std::cout << "难度：" << examQuestions[index].getDifficulty() << std::endl;

    // 获取新题目ID
    std::string newId;
    std::cout << "请输入新题目ID: ";
    std::getline(std::cin, newId);

    // 在题库中查找新题目
    int newQuestionIndex = -1;
    for (size_t i = 0; i < allQuestions.size(); ++i) {
        if (allQuestions[i].getId() == newId) {
            newQuestionIndex = static_cast<int>(i);
            break;
        }
    }

    if (newQuestionIndex == -1) {
        std::cout << "未找到ID为 " << newId << " 的题目!" << std::endl;
        return false;
    }

    // 显示新题目
    std::cout << "新题目: " << std::endl;
    std::cout << "[" << allQuestions[newQuestionIndex].getId() << "]" << std::endl;
    std::cout << "题干：" << allQuestions[newQuestionIndex].getContent() << std::endl;
    std::cout << "知识点：" << allQuestions[newQuestionIndex].getTag() << std::endl;
    std::cout << "难度：" << allQuestions[newQuestionIndex].getDifficulty() << std::endl;

    // 确认替换
    std::string confirm;
    std::cout << "确认替换题目? (y/n): ";
    std::getline(std::cin, confirm);

    if (confirm != "y" && confirm != "Y") {
        std::cout << "已取消替换!" << std::endl;
        return false;
    }

    // 替换题目
    examQuestions[index] = allQuestions[newQuestionIndex];

    // 保存修改后的试卷
    std::string newExamFilename;
    std::cout << "请输入新的试卷文件名 (留空则覆盖原文件): ";
    std::getline(std::cin, newExamFilename);

    if (newExamFilename.empty()) {
        newExamFilename = examFilename;
    }

    if (writeExamToFile(newExamFilename, examQuestions)) {
        std::cout << "试卷已成功保存：" << newExamFilename << std::endl;
        return true;
    }
    else {
        std::cout << "试卷保存失败！" << std::endl;
        return false;
    }
}

// 自定义读取函数，支持处理多种编码格式
std::vector<Question> ExamModifier::readExamFromFile(const std::string& examFilename) {
    std::vector<Question> questions;
    std::ifstream file(examFilename);
    if (!file.is_open()) {
        std::cerr << "无法打开文件: " << examFilename << std::endl;
        return questions;
    }

    std::string line;
    std::string id, content, tag;
    std::vector<std::string> options, answers;
    int difficulty = 1;

    while (std::getline(file, line)) {
        // 去除BOM标记如果存在
        if (!line.empty() && line.size() >= 3 &&
            (unsigned char)line[0] == 0xEF &&
            (unsigned char)line[1] == 0xBB &&
            (unsigned char)line[2] == 0xBF) {
            line = line.substr(3);
        }

        // 跳过空行
        if (line.empty()) continue;

        // 处理ID行
        if (line.find('[') != std::string::npos && line.find(']') != std::string::npos) {
            // 如果已经有了一个完整的题目，添加到列表中
            if (!id.empty() && !content.empty()) {
                Question q(id, content, options, answers, tag, difficulty);
                questions.push_back(q);

                // 重置变量
                id = "";
                content = "";
                tag = "";
                options.clear();
                answers.clear();
                difficulty = 1;
            }

            // 提取ID
            size_t start = line.find('[') + 1;
            size_t end = line.find(']');
            if (start < end) {
                id = line.substr(start, end - start);
            }
        }
        // 处理题干行
        else if (line.find("题干：") != std::string::npos) {
            content = line.substr(line.find("题干：") + 5);
        }
        // 处理选项行
        else if (line.find("选项：") != std::string::npos) {
            std::string optLine = line.substr(line.find("选项：") + 5);
            std::istringstream iss(optLine);
            options.clear();
            std::string opt;
            while (iss >> opt) {
                options.push_back(opt);
            }
        }
        // 处理答案行
        else if (line.find("答案：") != std::string::npos) {
            std::string ansLine = line.substr(line.find("答案：") + 5);
            std::istringstream iss(ansLine);
            answers.clear();
            std::string ans;
            while (std::getline(iss, ans, ',')) {
                answers.push_back(ans);
            }
        }
        // 处理知识点行
        else if (line.find("知识点：") != std::string::npos) {
            tag = line.substr(line.find("知识点：") + 8);
        }
        // 处理难度行
        else if (line.find("难度：") != std::string::npos) {
            std::string diffStr = line.substr(line.find("难度：") + 5);
            try {
                difficulty = std::stoi(diffStr);
            }
            catch (...) {
                difficulty = 1;
            }
        }
    }

    // 添加最后一个题目
    if (!id.empty() && !content.empty()) {
        Question q(id, content, options, answers, tag, difficulty);
        questions.push_back(q);
    }

    file.close();

    // 如果仍然为空，尝试用二进制方式读取并处理
    if (questions.empty()) {
        questions = readExamFromBinaryFile(examFilename);
    }

    return questions;
}

// 尝试从二进制文件中读取题目，处理不同编码
std::vector<Question> ExamModifier::readExamFromBinaryFile(const std::string& examFilename) {
    std::vector<Question> questions;
    std::ifstream file(examFilename, std::ios::binary);
    if (!file.is_open()) {
        return questions;
    }

    // 读取整个文件内容
    std::string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
    file.close();

    // 检测BOM并移除
    bool hasBOM = false;
    if (content.size() >= 3 &&
        (unsigned char)content[0] == 0xEF &&
        (unsigned char)content[1] == 0xBB &&
        (unsigned char)content[2] == 0xBF) {
        content = content.substr(3);
        hasBOM = true;
    }

    // 解析内容
    std::istringstream iss(content);
    std::string line;
    std::string id, questionContent, tag;
    std::vector<std::string> options, answers;
    int difficulty = 1;

    while (std::getline(iss, line)) {
        // 跳过空行
        if (line.empty()) continue;

        // 处理ID行
        if (line.find('[') != std::string::npos && line.find(']') != std::string::npos) {
            // 如果已经有了一个完整的题目，添加到列表中
            if (!id.empty() && !questionContent.empty()) {
                Question q(id, questionContent, options, answers, tag, difficulty);
                questions.push_back(q);

                // 重置变量
                id = "";
                questionContent = "";
                tag = "";
                options.clear();
                answers.clear();
                difficulty = 1;
            }

            // 提取ID
            size_t start = line.find('[') + 1;
            size_t end = line.find(']');
            if (start < end) {
                id = line.substr(start, end - start);
            }
        }
        // 尝试查找"题干："或者类似的内容，即使有乱码也尝试匹配
        else if (line.find("题干") != std::string::npos) {
            size_t pos = line.find("题干");
            questionContent = line.substr(pos + 2); // 跳过"题干"和可能的分隔符
        }
        // 尝试查找"选项："或者类似的内容
        else if (line.find("选项") != std::string::npos) {
            size_t pos = line.find("选项");
            std::string optLine = line.substr(pos + 2); // 跳过"选项"和可能的分隔符
            std::istringstream optIss(optLine);
            options.clear();
            std::string opt;
            while (optIss >> opt) {
                options.push_back(opt);
            }
        }
        // 尝试查找"答案："或者类似的内容
        else if (line.find("答案") != std::string::npos) {
            size_t pos = line.find("答案");
            std::string ansLine = line.substr(pos + 2); // 跳过"答案"和可能的分隔符
            std::istringstream ansIss(ansLine);
            answers.clear();
            std::string ans;
            while (std::getline(ansIss, ans, ',')) {
                answers.push_back(ans);
            }
        }
        // 尝试查找"知识点："或者类似的内容
        else if (line.find("知识点") != std::string::npos) {
            size_t pos = line.find("知识点");
            tag = line.substr(pos + 3); // 跳过"知识点"和可能的分隔符
        }
        // 尝试查找"难度："或者类似的内容
        else if (line.find("难度") != std::string::npos) {
            size_t pos = line.find("难度");
            std::string diffStr = line.substr(pos + 2); // 跳过"难度"和可能的分隔符
            // 尝试提取数字
            for (char c : diffStr) {
                if (isdigit(c)) {
                    difficulty = c - '0';
                    break;
                }
            }
        }
    }

    // 添加最后一个题目
    if (!id.empty() && !questionContent.empty()) {
        Question q(id, questionContent, options, answers, tag, difficulty);
        questions.push_back(q);
    }

    return questions;
}

bool ExamModifier::writeExamToFile(const std::string& examFilename, const std::vector<Question>& examQuestions) {
    // 使用标准的ofstream以ANSI编码写入，与原始生成方式保持一致
    std::ofstream ofs(examFilename);
    if (!ofs.is_open()) {
        return false;
    }

    for (const auto& question : examQuestions) {
        ofs << "[" << question.getId() << "]\n"
            << "题干：" << question.getContent() << "\n"
            << "选项：";

        // 处理选项
        std::vector<std::string> options = question.getOptions();
        for (size_t i = 0; i < options.size(); ++i) {
            ofs << options[i];
            if (i < options.size() - 1) ofs << " ";
        }

        ofs << "\n答案：";
        std::vector<std::string> answers = question.getAnswer();
        for (size_t i = 0; i < answers.size(); ++i) {
            ofs << answers[i];
            if (i < answers.size() - 1) ofs << ",";
        }

        ofs << "\n知识点：" << question.getTag() << "\n"
            << "难度：" << question.getDifficulty() << "\n\n";
    }

    ofs.close();
    return true;
}

// 仅修改displayExamQuestions方法，用于清理显示内容中的乱码
void ExamModifier::displayExamQuestions(const std::vector<Question>& examQuestions) {
    for (size_t i = 0; i < examQuestions.size(); ++i) {
        std::cout << "题目 " << i << ":" << std::endl;
        std::cout << "[" << examQuestions[i].getId() << "]" << std::endl;

        // 清理题干中的乱码
        std::string content = examQuestions[i].getContent();
        std::string cleanedContent = cleanChineseText(content);
        std::cout << "题干：" << cleanedContent << std::endl;

        // 清理选项中的乱码
        std::cout << "选项：";
        std::vector<std::string> options = examQuestions[i].getOptions();
        for (size_t j = 0; j < options.size(); ++j) {
            std::string cleanedOption = cleanChineseText(options[j]);
            std::cout << cleanedOption;
            if (j < options.size() - 1) std::cout << " ";
        }
        std::cout << std::endl;

        // 清理答案中的乱码
        std::cout << "答案：";
        std::vector<std::string> answers = examQuestions[i].getAnswer();
        for (size_t j = 0; j < answers.size(); ++j) {
            std::string cleanedAnswer = cleanChineseText(answers[j]);
            std::cout << cleanedAnswer;
            if (j < answers.size() - 1) std::cout << ",";
        }
        std::cout << std::endl;

        // 清理知识点中的乱码
        std::string tag = examQuestions[i].getTag();
        std::string cleanedTag = cleanChineseText(tag);
        std::cout << "知识点：" << cleanedTag << std::endl;

        std::cout << "难度：" << examQuestions[i].getDifficulty() << std::endl << std::endl;
    }
}

// 添加一个新的辅助方法用于清理文本中的乱码
std::string ExamModifier::cleanChineseText(const std::string& text) {
    std::string cleaned;
    for (size_t i = 0; i < text.length(); ++i) {
        unsigned char c = text[i];

        // 如果是可见的ASCII字符，保留
        if (c >= 32 && c <= 126) {
            cleaned.push_back(c);
            continue;
        }

        // 如果是C++, C#等编程语言常见符号前的乱码，直接跳过
        if (i + 1 < text.length() && text[i + 1] == '+') {
            if (text.substr(i + 1, 2) == "++") {
                cleaned.append("C++");
                i += 2; // 跳过 "++"
                continue;
            }
        }

        // 如果是常见选项前的乱码（例如A.B.C.D.前的乱码），替换为正确的选项标识
        if (i + 1 < text.length() && text[i + 1] == '.') {
            if (i + 2 < text.length()) {
                char nextChar = text[i + 2];
                // 如果乱码后面紧跟着选项，如".const"中的const
                if (isalpha(nextChar) || isdigit(nextChar)) {
                    // 判断这是第几个选项
                    size_t optionPos = cleaned.length();
                    int optionIndex = -1;

                    // 找出已经处理的选项数量
                    size_t pos = 0;
                    while ((pos = cleaned.find(".", pos)) != std::string::npos) {
                        optionIndex++;
                        pos++;
                    }

                    // 根据选项索引添加正确的选项标识
                    switch (optionIndex + 1) {
                    case 1: cleaned.append("A."); break;
                    case 2: cleaned.append("B."); break;
                    case 3: cleaned.append("C."); break;
                    case 4: cleaned.append("D."); break;
                    case 5: cleaned.append("E."); break;
                    default: cleaned.append("?."); break;
                    }
                    i += 1; // 跳过 "."
                    continue;
                }
            }
        }

        // 处理常见的中文乱码模式
        // 这里可以添加更多的乱码模式识别和替换规则

        // 默认情况：跳过不可见的字符
        if (c < 32 || c > 126) {
            continue;
        }
    }

    return cleaned;
}